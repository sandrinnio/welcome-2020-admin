"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDocPerOp = createDocPerOp;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var definitionRefs;

function createDocPerOp(_ref) {
  var doc = _ref.ast,
      isOnlyFrags = _ref.isOnlyFrags;

  if (doc.definitions.length === 1) {
    var name = doc.definitions[0].name;
    return name ? {
      default: doc,
      [name.value]: doc
    } : {
      default: doc
    };
  }

  definitionRefs = {};
  doc.definitions.forEach(function (def) {
    if (def.name) {
      var refs = new Set();
      collectRefs(def, refs);
      definitionRefs[def.name.value] = refs;
    }
  });
  var docs = {};

  if (!isOnlyFrags) {
    while (doc.definitions[0].kind !== 'OperationDefinition') {
      var _doc$definitions = _toArray(doc.definitions),
          head = _doc$definitions[0],
          tail = _doc$definitions.slice(1);

      doc.definitions = _toConsumableArray(tail).concat([head]);
    }
  }

  doc.definitions.forEach(function (op, i) {
    if (op.kind === 'OperationDefinition' || op.kind === 'FragmentDefinition') {
      if (!op.name) {
        throw new Error('Names are required for a document with multiple Queries/Mutations');
      }

      var curOpDoc = createSingleOperationDoc(doc, op.name.value);

      if (i === 0) {
        docs.default = curOpDoc;
        docs[op.name.value] = curOpDoc;
      } else {
        docs[op.name.value] = curOpDoc;
      }
    }
  });
  return docs;
}

function collectRefs(_ref2, refs) {
  var kind = _ref2.kind,
      type = _ref2.type,
      name = _ref2.name,
      selectionSet = _ref2.selectionSet,
      variableDefinitions = _ref2.variableDefinitions,
      definitions = _ref2.definitions;

  if (kind === 'FragmentSpread') {
    refs.add(name.value);
  } else if (kind === 'VariableDefinition') {
    var t = type;
    if (t.kind === 'NamedType') refs.add(type.name.value);
    if (t.kind === 'NonNullType' && t.type.kind === 'NamedType') refs.add(type.type.name.value);
  } // Call recursively for types that may contain FragmentSpread or NamedType, if those types exist


  definitions && definitions.forEach(function (def) {
    return collectRefs(def, refs);
  });
  selectionSet && selectionSet.selections.forEach(function (sel) {
    return collectRefs(sel, refs);
  });
  variableDefinitions && variableDefinitions.forEach(function (def) {
    return collectRefs(def, refs);
  });
}

function findOperation(doc, name) {
  return doc.definitions.find(function (op) {
    return op.name ? op.name.value === name : false;
  });
}

function createSingleOperationDoc(doc, operationName) {
  // Copy the DocumentNode, but clear out the definitions
  var newDoc = Object.assign({}, doc);
  newDoc.definitions = [findOperation(doc, operationName)]; // For the current operation, find any fragments referenced by: it, or fragments it references

  var allRefs = new Set();
  var newRefs = new Set(definitionRefs[operationName]);

  while (newRefs.size > 0) {
    var prevRefs = newRefs;
    newRefs = new Set();
    prevRefs.forEach(function (refName) {
      if (!allRefs.has(refName)) {
        allRefs.add(refName);
        var childRefs = definitionRefs[refName] || new Set();
        childRefs.forEach(function (childRef) {
          return newRefs.add(childRef);
        });
      }
    });
  }

  allRefs.forEach(function (refName) {
    var op = findOperation(doc, refName);
    if (op) newDoc.definitions.push(op);
  });
  return newDoc;
}